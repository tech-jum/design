(window.webpackJsonp=window.webpackJsonp||[]).push([[27],{424:function(t,r,_){"use strict";_.r(r);var v=_(15),a=Object(v.a)({},(function(){var t=this,r=t.$createElement,_=t._self._c||r;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h1",{attrs:{id:"分布式存储基本原理"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#分布式存储基本原理"}},[t._v("#")]),t._v(" 分布式存储基本原理")]),t._v(" "),_("blockquote",[_("p",[t._v("分片（Sharding）的基本思想就要把一个数据库切分成多个部分，存储在不同的数据库(server)上，从而缓解单一数据库的性能问题。")]),t._v(" "),_("p",[t._v("分库分表一定是为了支撑 "),_("strong",[t._v("高并发、数据量大")]),t._v(" 两个问题的。")]),t._v(" "),_("p",[t._v("📦 本文已归档到：「"),_("a",{attrs:{href:"https://github.com/dunwu/blog",target:"_blank",rel:"noopener noreferrer"}},[t._v("blog"),_("OutboundLink")],1),t._v("」")])]),t._v(" "),_("ul",[_("li",[_("a",{attrs:{href:"#%E4%B8%80%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB"}},[t._v("一、读写分离")]),t._v(" "),_("ul",[_("li",[_("a",{attrs:{href:"#%E4%B8%BA%E4%BD%95%E8%A6%81%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB"}},[t._v("为何要读写分离")])]),t._v(" "),_("li",[_("a",{attrs:{href:"#%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E7%9A%84%E5%8E%9F%E7%90%86"}},[t._v("读写分离的原理")])]),t._v(" "),_("li",[_("a",{attrs:{href:"#%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E7%9A%84%E9%97%AE%E9%A2%98"}},[t._v("读写分离的问题")])])])]),t._v(" "),_("li",[_("a",{attrs:{href:"#%E4%BA%8C%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8"}},[t._v("二、分库分表")]),t._v(" "),_("ul",[_("li",[_("a",{attrs:{href:"#%E4%B8%BA%E4%BD%95%E8%A6%81%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8"}},[t._v("为何要分库分表")])]),t._v(" "),_("li",[_("a",{attrs:{href:"#%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E5%8E%9F%E7%90%86"}},[t._v("分库分表原理")])]),t._v(" "),_("li",[_("a",{attrs:{href:"#%E8%BF%81%E7%A7%BB%E5%92%8C%E6%89%A9%E5%AE%B9"}},[t._v("迁移和扩容")])]),t._v(" "),_("li",[_("a",{attrs:{href:"#%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E7%9A%84%E9%97%AE%E9%A2%98"}},[t._v("分库分表的问题")])])])]),t._v(" "),_("li",[_("a",{attrs:{href:"#%E4%B8%89%E4%B8%AD%E9%97%B4%E4%BB%B6"}},[t._v("三、中间件")])]),t._v(" "),_("li",[_("a",{attrs:{href:"#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"}},[t._v("参考资料")])])]),t._v(" "),_("h2",{attrs:{id:"一、读写分离"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#一、读写分离"}},[t._v("#")]),t._v(" 一、读写分离")]),t._v(" "),_("p",[_("strong",[t._v("读写分离的基本原理是：主服务器用来处理写操作以及实时性要求比较高的读操作，而从服务器用来处理读操作")]),t._v("。")]),t._v(" "),_("h3",{attrs:{id:"为何要读写分离"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#为何要读写分离"}},[t._v("#")]),t._v(" 为何要读写分离")]),t._v(" "),_("ul",[_("li",[_("strong",[t._v("有效减少锁竞争")]),t._v(" - 主服务器只负责写，从服务器只负责读，能够有效的避免由数据更新导致的行锁竞争，使得整个系统的查询性能得到极大的改善。")]),t._v(" "),_("li",[_("strong",[t._v("提高查询吞吐量")]),t._v(" - 通过一主多从的配置方式，可以将查询请求均匀的分散到多个数据副本，能够进一步的提升系统的处理能力。")]),t._v(" "),_("li",[_("strong",[t._v("提升数据库可用性")]),t._v(" - 使用多主多从的方式，不但能够提升系统的吞吐量，还能够提升数据库的可用性，可以达到在任何一个数据库宕机，甚至磁盘物理损坏的情况下仍然不影响系统的正常运行。")])]),t._v(" "),_("h3",{attrs:{id:"读写分离的原理"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#读写分离的原理"}},[t._v("#")]),t._v(" 读写分离的原理")]),t._v(" "),_("p",[t._v("读写分离的实现是根据 SQL 语义分析，将读操作和写操作分别路由至主库与从库。")]),t._v(" "),_("p",[_("img",{attrs:{src:"https://shardingsphere.apache.org/document/current/img/read-write-split/read-write-split.png",alt:"读写分离"}})]),t._v(" "),_("p",[t._v("读写分离的基本实现是：")]),t._v(" "),_("p",[_("img",{attrs:{src:"https://raw.githubusercontent.com/dunwu/images/dev/cs/database/mysql/master-slave-proxy.png",alt:"img"}})]),t._v(" "),_("ul",[_("li",[t._v("数据库服务器搭建主从集群，一主一从、一主多从都可以。")]),t._v(" "),_("li",[t._v("数据库主机负责读写操作，从机只负责读操作。")]),t._v(" "),_("li",[t._v("数据库主机通过复制将数据同步到从机，每台数据库服务器都存储了全量数据。")]),t._v(" "),_("li",[t._v("业务服务器将写操作发给数据库主机，将读操作发给数据库从机。")]),t._v(" "),_("li",[t._v("主机会记录请求的二进制日志，然后推送给从库，从库解析并执行日志中的请求，完成主从复制。这意味着：复制过程存在时延，这段时间内，主从数据可能不一致。")])]),t._v(" "),_("h3",{attrs:{id:"读写分离的问题"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#读写分离的问题"}},[t._v("#")]),t._v(" 读写分离的问题")]),t._v(" "),_("p",[t._v("读写分离存在两个问题："),_("strong",[t._v("数据一致性")]),t._v("和"),_("strong",[t._v("分发机制")]),t._v("。")]),t._v(" "),_("h4",{attrs:{id:"数据一致性"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#数据一致性"}},[t._v("#")]),t._v(" 数据一致性")]),t._v(" "),_("p",[t._v("读写分离产生了主库与从库之间的数据一致性的问题。")]),t._v(" "),_("p",[_("img",{attrs:{src:"https://shardingsphere.apache.org/document/current/img/read-write-split/sharding-read-write-split.png",alt:"数据分片 + 读写分离"}})]),t._v(" "),_("h4",{attrs:{id:"分发机制"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#分发机制"}},[t._v("#")]),t._v(" 分发机制")]),t._v(" "),_("p",[t._v("数据库读写分离后，一个 SQL 请求具体分发到哪个数据库节点？一般有两种分发方式：客户端分发和中间件代理分发。")]),t._v(" "),_("p",[t._v("客户端分发，是基于程序代码，自行控制数据分发到哪个数据库节点。更细一点来说，一般程序中建立多个数据库的连接，根据一定的算法，选择合适的连接去发起 SQL 请求。这种方式也被称为客户端中间件，代表有：jdbc-sharding。")]),t._v(" "),_("p",[t._v("中间件代理分发，指的是独立一套系统出来，实现读写操作分离和数据库服务器连接的管理。中间件对业务服务器提供 SQL 兼容的协议，业务服务器无须自己进行读写分离。对于业务服务器来说，访问中间件和访问数据库没有区别，事实上在业务服务器看来，中间件就是一个数据库服务器。代表有：Mycat。")]),t._v(" "),_("h2",{attrs:{id:"二、分库分表"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#二、分库分表"}},[t._v("#")]),t._v(" 二、分库分表")]),t._v(" "),_("h3",{attrs:{id:"为何要分库分表"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#为何要分库分表"}},[t._v("#")]),t._v(" 为何要分库分表")]),t._v(" "),_("p",[t._v("分库分表主要基于以下理由：")]),t._v(" "),_("ul",[_("li",[_("strong",[t._v("并发连接")]),t._v(" - 单库超过每秒 2000 个并发时，而一个健康的单库最好保持在每秒 1000 个并发左右，不要太大。")]),t._v(" "),_("li",[_("strong",[t._v("磁盘容量")]),t._v(" - 磁盘容量占满，会导致服务器不可用。")]),t._v(" "),_("li",[_("strong",[t._v("SQL 性能")]),t._v(" - 单表数据量过大，会导致 SQL 执行效率低下。一般，单表有 200 万条数据，就可以考虑分表了。")])]),t._v(" "),_("table",[_("thead",[_("tr",[_("th",[t._v("#")]),t._v(" "),_("th",[t._v("分库分表前")]),t._v(" "),_("th",[t._v("分库分表后")])])]),t._v(" "),_("tbody",[_("tr",[_("td",[t._v("并发支撑情况")]),t._v(" "),_("td",[t._v("MySQL 单机部署，扛不住高并发")]),t._v(" "),_("td",[t._v("MySQL 从单机到多机，能承受的并发增加了多倍")])]),t._v(" "),_("tr",[_("td",[t._v("磁盘使用情况")]),t._v(" "),_("td",[t._v("MySQL 单机磁盘容量几乎撑满")]),t._v(" "),_("td",[t._v("拆分为多个库，数据库服务器磁盘使用率大大降低")])]),t._v(" "),_("tr",[_("td",[t._v("SQL 执行性能")]),t._v(" "),_("td",[t._v("单表数据量太大，SQL 越跑越慢")]),t._v(" "),_("td",[t._v("单表数据量减少，SQL 执行效率明显提升")])])])]),t._v(" "),_("h3",{attrs:{id:"分库分表原理"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#分库分表原理"}},[t._v("#")]),t._v(" 分库分表原理")]),t._v(" "),_("p",[_("strong",[t._v("数据分片指按照某个维度将存放在单一数据库中的数据分散地存放至多个数据库或表中以达到提升性能瓶颈以及可用性的效果")]),t._v("。 数据分片的有效手段是对关系型数据库进行分库和分表。分库和分表均可以有效的避免由数据量超过可承受阈值而产生的查询瓶颈。 除此之外，分库还能够用于有效的分散对数据库单点的访问量；分表虽然无法缓解数据库压力，但却能够提供尽量将分布式事务转化为本地事务的可能，一旦涉及到跨库的更新操作，分布式事务往往会使问题变得复杂。 使用多主多从的分片方式，可以有效的避免数据单点，从而提升数据架构的可用性。")]),t._v(" "),_("p",[t._v("通过分库和分表进行数据的拆分来使得各个表的数据量保持在阈值以下，以及对流量进行疏导应对高访问量，是应对高并发和海量数据系统的有效手段。 数据分片的拆分方式又分为垂直分片和水平分片。")]),t._v(" "),_("h4",{attrs:{id:"垂直分片"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#垂直分片"}},[t._v("#")]),t._v(" 垂直分片")]),t._v(" "),_("p",[t._v("垂直分片有两种拆分考量：业务拆分和访问频率拆分")]),t._v(" "),_("p",[t._v("（1）业务拆分")]),t._v(" "),_("blockquote",[_("p",[t._v("业务拆分的核心理念是"),_("strong",[t._v("专库专用")]),t._v("。")])]),t._v(" "),_("p",[t._v("在拆分之前，一个数据库由多个数据表构成，每个表对应着不同的业务。而拆分之后，则是"),_("strong",[t._v("按照业务将表进行归类，分布到不同的数据库中")]),t._v("，从而将压力分散至不同的数据库。下图展示了根据业务需要，将用户表和订单表垂直分片到不同的数据库的方案。")]),t._v(" "),_("p",[t._v("垂直分片往往需要对架构和设计进行调整。通常来讲，是来不及应对互联网业务需求快速变化的；而且，它也并无法真正的解决单点瓶颈。"),_("strong",[t._v("垂直拆分可以缓解数据量和访问量带来的问题，但无法根治。如果垂直拆分之后，表中的数据量依然超过单节点所能承载的阈值，则需要水平分片来进一步处理")]),t._v("。")]),t._v(" "),_("p",[t._v("（2）访问频率拆分")]),t._v(" "),_("blockquote",[_("p",[t._v("访问频率拆分，是 "),_("strong",[t._v("把一个有很多字段的表给拆分成多个表，或者是多个库上去")]),t._v("。一般来说，会 "),_("strong",[t._v("将较少的、访问频率较高的字段放到一个表中")]),t._v("，然后 "),_("strong",[t._v("将较多的、访问频率较低的字段放到另外一个表中")]),t._v("。因为数据库是有缓存的，访问频率高的行字段越少，就可以在缓存里缓存更多的行，性能就越好。这个一般在表层面做的较多一些。")])]),t._v(" "),_("p",[_("img",{attrs:{src:"https://raw.githubusercontent.com/dunwu/images/dev/snap/image-20200114211639899.png",alt:"image-20200114211639899"}})]),t._v(" "),_("p",[t._v("一般来说，满足下面的条件就可以考虑扩容了：")]),t._v(" "),_("ul",[_("li",[t._v("Mysql 单库超过 5000 万条记录，Oracle 单库超过 1 亿条记录，DB 压力就很大。")]),t._v(" "),_("li",[t._v("单库超过每秒 2000 个并发时，而一个健康的单库最好保持在每秒 1000 个并发左右，不要太大。")])]),t._v(" "),_("p",[t._v("在数据库的层面使用垂直切分将按数据库中表的密集程度部署到不同的库中，例如将原来的电商数据库垂直切分成商品数据库、用户数据库等。")]),t._v(" "),_("h4",{attrs:{id:"水平分片"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#水平分片"}},[t._v("#")]),t._v(" 水平分片")]),t._v(" "),_("blockquote",[_("p",[_("strong",[t._v("水平拆分")]),t._v(" 又称为 "),_("strong",[t._v("Sharding")]),t._v("，它是将同一个表中的记录拆分到多个结构相同的表中。当 "),_("strong",[t._v("单表数据量太大")]),t._v(" 时，会极大影响 "),_("strong",[t._v("SQL 执行的性能")]),t._v(" 。分表是将原来一张表的数据分布到数据库集群的不同节点上，从而缓解单点的压力。")])]),t._v(" "),_("p",[t._v("相对于垂直分片，水平分片不再将数据根据业务逻辑分类，而是通过某个字段（或某几个字段），根据某种规则将数据分散至多个库或表中，每个分片仅包含数据的一部分。 例如：根据主键分片，偶数主键的记录放入 0 库（或表），奇数主键的记录放入 1 库（或表）。")]),t._v(" "),_("p",[t._v("水平分片从理论上突破了单机数据量处理的瓶颈，并且扩展相对自由，是分库分表的标准解决方案。")]),t._v(" "),_("p",[_("img",{attrs:{src:"https://raw.githubusercontent.com/dunwu/images/dev/snap/image-20200114211203589.png",alt:"image-20200114211203589"}})]),t._v(" "),_("p",[t._v("一般来说，"),_("strong",[t._v("单表有 200 万条数据")]),t._v(" 的时候，性能就会相对差一些了，需要考虑分表了。但是，这也要视具体情况而定，可能是 100 万条，也可能是 500 万条，SQL 越复杂，就最好让单表行数越少。")]),t._v(" "),_("p",[t._v("读写分离的数据节点中的数据内容是一致的，而水平分片的每个数据节点的数据内容却并不相同。将水平分片和读写分离联合使用，能够更加有效的提升系统性能。")]),t._v(" "),_("h4",{attrs:{id:"分库分表策略"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#分库分表策略"}},[t._v("#")]),t._v(" 分库分表策略")]),t._v(" "),_("p",[_("img",{attrs:{src:"https://raw.githubusercontent.com/dunwu/images/dev/snap/20200608091832.png",alt:"img"}})]),t._v(" "),_("p",[t._v("分库分表策略主要有两种：")]),t._v(" "),_("ul",[_("li",[t._v("根据数值范围划分")]),t._v(" "),_("li",[t._v("根据 Hash 划分")])]),t._v(" "),_("h5",{attrs:{id:"数值范围路由"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#数值范围路由"}},[t._v("#")]),t._v(" 数值范围路由")]),t._v(" "),_("p",[t._v("数值范围路由，就是根据 ID、时间范围 这类具有排序性的字段来进行划分。例如：用户 Id 为 1-9999 的记录分到第一个库，10000-20000 的分到第二个库，以此类推。")]),t._v(" "),_("p",[t._v("按这种策略划分出来的数据，具有数据连续性。")]),t._v(" "),_("p",[t._v("优点：数据迁移很简单。")]),t._v(" "),_("p",[t._v("缺点：容易产生热点问题，大量的流量都打在最新的数据上了。")]),t._v(" "),_("h5",{attrs:{id:"hash-路由"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#hash-路由"}},[t._v("#")]),t._v(" Hash 路由")]),t._v(" "),_("p",[_("img",{attrs:{src:"C:%5CUsers%5Czp%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200608092034118.png",alt:"image-20200608092034118"}})]),t._v(" "),_("p",[t._v("典型的 Hash 路由，如根据数值取模，当需要扩容时，一般以 2 的幂次方进行扩容（这样，扩容时迁移的数据量会小一些）。例如：用户 Id mod n，余数为 0 的记录放到第一个库，余数为 1 的放到第二个库，以此类推。")]),t._v(" "),_("p",[t._v("一般采用 "),_("strong",[t._v("预分区")]),t._v(" 的方式，提前根据 "),_("strong",[t._v("数据量")]),t._v(" 规划好 "),_("strong",[t._v("分区数")]),t._v("，比如划分为 "),_("code",[t._v("512")]),t._v(" 或 "),_("code",[t._v("1024")]),t._v(" 张表，保证可支撑未来一段时间的 "),_("strong",[t._v("数据容量")]),t._v("，再根据 "),_("strong",[t._v("负载情况")]),t._v(" 将 "),_("strong",[t._v("表")]),t._v(" 迁移到其他 "),_("strong",[t._v("数据库")]),t._v(" 中。扩容时通常采用 "),_("strong",[t._v("翻倍扩容")]),t._v("，避免 "),_("strong",[t._v("数据映射")]),t._v(" 全部被 "),_("strong",[t._v("打乱")]),t._v("，导致 "),_("strong",[t._v("全量迁移")]),t._v(" 的情况。")]),t._v(" "),_("p",[t._v("优点：数据离散分布，不存在热点问题。")]),t._v(" "),_("p",[t._v("缺点：数据迁移、扩容麻烦（之前的数据需要重新计算 hash 值重新分配到不同的库或表）。当 "),_("strong",[t._v("节点数量")]),t._v(" 变化时，如 "),_("strong",[t._v("扩容")]),t._v(" 或 "),_("strong",[t._v("收缩")]),t._v(" 节点，数据节点 "),_("strong",[t._v("映射关系")]),t._v(" 需要重新计算，会导致数据的 "),_("strong",[t._v("重新迁移")]),t._v("。")]),t._v(" "),_("h5",{attrs:{id:"路由表"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#路由表"}},[t._v("#")]),t._v(" 路由表")]),t._v(" "),_("p",[t._v("这种策略，就是用一张独立的表记录路由信息。")]),t._v(" "),_("p",[t._v("优点：简单、灵活，尤其是在扩容、迁移时，只需要迁移指定的数据，然后修改路由表即可。")]),t._v(" "),_("p",[t._v("缺点：每次查询，必须先查路由表，增加了 IO 开销。并且，如果路由表本身太大，也会面临性能瓶颈，如果想对路由表再做分库分表，将出现死循环式的路由算法选择问题。")]),t._v(" "),_("h3",{attrs:{id:"迁移和扩容"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#迁移和扩容"}},[t._v("#")]),t._v(" 迁移和扩容")]),t._v(" "),_("h4",{attrs:{id:"停机迁移-扩容-不推荐"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#停机迁移-扩容-不推荐"}},[t._v("#")]),t._v(" 停机迁移/扩容（不推荐）")]),t._v(" "),_("p",[t._v("停机迁移/扩容是最暴力、最简单的迁移、扩容方案。")]),t._v(" "),_("p",[_("img",{attrs:{src:"https://raw.githubusercontent.com/dunwu/images/dev/snap/20200601114836.png",alt:"img"}})]),t._v(" "),_("h5",{attrs:{id:"停机迁移-扩容流程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#停机迁移-扩容流程"}},[t._v("#")]),t._v(" 停机迁移/扩容流程")]),t._v(" "),_("p",[t._v("（0）预估停服时间，发布停服公告。")]),t._v(" "),_("p",[t._v("（1）停服，不允许数据访问。")]),t._v(" "),_("p",[t._v("（2）编写临时的数据导入程序，从老数据库中读取数据。")]),t._v(" "),_("p",[t._v("（3）将数据写入中间件。")]),t._v(" "),_("p",[t._v("（4）中间件根据分片规则，将数据分发到分库（分表）中。")]),t._v(" "),_("p",[t._v("（5）应用程序修改配置，重启。")]),t._v(" "),_("h5",{attrs:{id:"停机迁移-扩容方案分析"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#停机迁移-扩容方案分析"}},[t._v("#")]),t._v(" 停机迁移/扩容方案分析")]),t._v(" "),_("p",[t._v("优点：简单、没有数据一致性问题。")]),t._v(" "),_("p",[t._v("缺点：如果老的数据库数据量很大，则停机处理时间可能很久。比如老的数据库是已经分库分表的数据库群，数据量可能达到亿级，导入数据可能就要花费几小时。如果中间过程中出现问题，就容易引发重大事故。")]),t._v(" "),_("p",[t._v("点评：综上，这种方案代价太高，不可取。")]),t._v(" "),_("h4",{attrs:{id:"双写迁移"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#双写迁移"}},[t._v("#")]),t._v(" 双写迁移")]),t._v(" "),_("p",[_("img",{attrs:{src:"https://raw.githubusercontent.com/dunwu/images/dev/snap/20200601135751.png",alt:"img"}})]),t._v(" "),_("h5",{attrs:{id:"双写迁移流程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#双写迁移流程"}},[t._v("#")]),t._v(" 双写迁移流程")]),t._v(" "),_("p",[t._v("（1）修改应用程序配置，将数据同时写入老数据库和中间件。这就是所谓的"),_("strong",[t._v("双写")]),t._v("，同时写俩库，老库和新库。")]),t._v(" "),_("p",[t._v("（2）编写临时程序，读取老数据库。")]),t._v(" "),_("p",[t._v("（3）将数据写入中间件。如果数据不存在，直接写入；如果数据存在，比较时间戳，只允许新数据覆盖老数据。")]),t._v(" "),_("p",[t._v("（4）导入数据后，有可能数据还是存在不一致，那么就对数据进行校验，比对新老库的每条数据。如果存在差异，针对差异数据，执行（3）。循环（3）、（4）步骤，直至数据完全一致。")]),t._v(" "),_("p",[t._v("（5）修改应用程序配置，将数据只写入中间件。")]),t._v(" "),_("p",[t._v("（6）中间件根据分片规则，将数据分发到分库（分表）中。")]),t._v(" "),_("h4",{attrs:{id:"主从升级"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#主从升级"}},[t._v("#")]),t._v(" 主从升级")]),t._v(" "),_("p",[t._v("生产环境的数据库，为了保证高可用，一般会采用主备架构。主库支持读写操作，从库支持读操作。")]),t._v(" "),_("p",[_("img",{attrs:{src:"https://raw.githubusercontent.com/dunwu/images/dev/snap/20200601121215.png",alt:"img"}})]),t._v(" "),_("p",[t._v("由于主备节点数据一致，所以将从库升级为主节点，并修改分片配置，将从节点作为分库之一，就实现了扩容。")]),t._v(" "),_("p",[_("img",{attrs:{src:"https://raw.githubusercontent.com/dunwu/images/dev/snap/20200601121400.png",alt:"img"}})]),t._v(" "),_("h5",{attrs:{id:"升级从库的流程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#升级从库的流程"}},[t._v("#")]),t._v(" 升级从库的流程")]),t._v(" "),_("p",[t._v("（1）解除主从关系，从库升级为主库。")]),t._v(" "),_("p",[t._v("（2）应用程序，修改配置，读写通过中间件。")]),t._v(" "),_("p",[t._v("（3）分库分表中间，修改分片配置。将数据按照新的规则分发。")]),t._v(" "),_("p",[t._v("（4）编写临时程序，清理冗余数据。比如：原来是一个单库，数据量为 400 万。从节点升级为分库之一后，每个分库都有 400 万数据，其中 200 万是冗余数据。清理完后，进行数据校验。")]),t._v(" "),_("p",[t._v("（5）为每个分库添加新的从库，保证高可用。")]),t._v(" "),_("h5",{attrs:{id:"升级从库方案分析"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#升级从库方案分析"}},[t._v("#")]),t._v(" 升级从库方案分析")]),t._v(" "),_("p",[t._v("优点：不需要停机，无需数据迁移。")]),t._v(" "),_("p",[t._v("缺点：")]),t._v(" "),_("h3",{attrs:{id:"分库分表的问题"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#分库分表的问题"}},[t._v("#")]),t._v(" 分库分表的问题")]),t._v(" "),_("h4",{attrs:{id:"分布式-id-问题"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#分布式-id-问题"}},[t._v("#")]),t._v(" 分布式 ID 问题")]),t._v(" "),_("p",[t._v("一旦数据库被切分到多个物理结点上，我们将不能再依赖数据库自身的主键生成机制。一方面，某个分区数据库自生成的 ID 无法保证在全局上是唯一的；另一方面，应用程序在插入数据之前需要先获得 ID，以便进行 SQL 路由。")]),t._v(" "),_("blockquote",[_("p",[t._v("分布式 ID 的解决方案详见："),_("a",{attrs:{href:"https://github.com/dunwu/blog/blob/master/source/_posts/theory/distributed-id.md",target:"_blank",rel:"noopener noreferrer"}},[t._v("分布式 ID"),_("OutboundLink")],1)])]),t._v(" "),_("h4",{attrs:{id:"分布式事务问题"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#分布式事务问题"}},[t._v("#")]),t._v(" 分布式事务问题")]),t._v(" "),_("p",[t._v("跨库事务也是分布式的数据库集群要面对的棘手事情。 合理采用分表，可以在降低单表数据量的情况下，尽量使用本地事务，善于使用同库不同表可有效避免分布式事务带来的麻烦。在不能避免跨库事务的场景，有些业务仍然需要保持事务的一致性。 而基于 XA 的分布式事务由于在并发度高的场景中性能无法满足需要，并未被互联网巨头大规模使用，他们大多采用最终一致性的柔性事务代替强一致事务。")]),t._v(" "),_("blockquote",[_("p",[t._v("分布式事务的解决方案详见："),_("a",{attrs:{href:"https://github.com/dunwu/blog/blob/master/source/_posts/theory/distributed-transaction.md",target:"_blank",rel:"noopener noreferrer"}},[t._v("分布式事务"),_("OutboundLink")],1)])]),t._v(" "),_("h4",{attrs:{id:"跨节点-join-和聚合"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#跨节点-join-和聚合"}},[t._v("#")]),t._v(" 跨节点 Join 和聚合")]),t._v(" "),_("p",[t._v("分库分表后，无法直接跨节点 "),_("code",[t._v("join")]),t._v(" 、"),_("code",[t._v("count")]),t._v("、"),_("code",[t._v("order by")]),t._v("、"),_("code",[t._v("group by")]),t._v(" 以及聚合。")]),t._v(" "),_("p",[t._v("针对这类问题，普遍做法是"),_("strong",[t._v("二次查询")]),t._v("。")]),t._v(" "),_("p",[t._v("在第一次查询时，获取各个节点上的结果。")]),t._v(" "),_("p",[t._v("在程序中将这些结果进行合并、筛选。")]),t._v(" "),_("h4",{attrs:{id:"跨分片的排序分页"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#跨分片的排序分页"}},[t._v("#")]),t._v(" 跨分片的排序分页")]),t._v(" "),_("p",[t._v("一般来讲，分页时需要按照指定字段进行排序。当排序字段就是分片字段的时候，我们通过分片规则可以比较容易定位到指定的分片，而当排序字段非分片字段的时候，情况就会变得比较复杂了。为了最终结果的准确性，我们需要在不同的分片节点中将数据进行排序并返回，并将不同分片返回的结果集进行汇总和再次排序，最后再返回给用户。如下图所示：")]),t._v(" "),_("p",[_("img",{attrs:{src:"https://upload-images.jianshu.io/upload_images/3710706-925381b9a478c8df.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640/format/webp",alt:"img"}})]),t._v(" "),_("p",[t._v("上面图中所描述的只是最简单的一种情况（取第一页数据），看起来对性能的影响并不大。但是，如果想取出第 10 页数据，情况又将变得复杂很多，如下图所示：")]),t._v(" "),_("p",[_("img",{attrs:{src:"https://upload-images.jianshu.io/upload_images/3710706-9a7cfbdb95bb9b70.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640/format/webp",alt:"img"}})]),t._v(" "),_("p",[t._v("有些读者可能并不太理解，为什么不能像获取第一页数据那样简单处理（排序取出前 10 条再合并、排序）。其实并不难理解，因为各分片节点中的数据可能是随机的，为了排序的准确性，必须把所有分片节点的前 N 页数据都排序好后做合并，最后再进行整体的排序。很显然，这样的操作是比较消耗资源的，用户越往后翻页，系统性能将会越差。")]),t._v(" "),_("p",[t._v("那如何解决分库情况下的分页问题呢？有以下几种办法：")]),t._v(" "),_("p",[t._v("如果是在前台应用提供分页，则限定用户只能看前面 n 页，这个限制在业务上也是合理的，一般看后面的分页意义不大（如果一定要看，可以要求用户缩小范围重新查询）。")]),t._v(" "),_("p",[t._v("如果是后台批处理任务要求分批获取数据，则可以加大 page size，比如每次获取 5000 条记录，有效减少分页数（当然离线访问一般走备库，避免冲击主库）。")]),t._v(" "),_("p",[t._v("分库设计时，一般还有配套大数据平台汇总所有分库的记录，有些分页查询可以考虑走大数据平台。")]),t._v(" "),_("h2",{attrs:{id:"三、中间件"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#三、中间件"}},[t._v("#")]),t._v(" 三、中间件")]),t._v(" "),_("p",[t._v("国内常见分库分表中间件：")]),t._v(" "),_("ul",[_("li",[_("a",{attrs:{href:"https://github.com/alibaba/cobar",target:"_blank",rel:"noopener noreferrer"}},[t._v("Cobar"),_("OutboundLink")],1),t._v(" - 阿里 b2b 团队开发和开源的，属于 proxy 层方案，就是介于应用服务器和数据库服务器之间。应用程序通过 JDBC 驱动访问 cobar 集群，cobar 根据 SQL 和分库规则对 SQL 做分解，然后分发到 MySQL 集群不同的数据库实例上执行。早些年还可以用，但是最近几年都没更新了，基本没啥人用，差不多算是被抛弃的状态吧。而且不支持读写分离、存储过程、跨库 join 和分页等操作。")]),t._v(" "),_("li",[_("a",{attrs:{href:"https://github.com/alibaba/tb_tddl",target:"_blank",rel:"noopener noreferrer"}},[t._v("TDDL"),_("OutboundLink")],1),t._v(" - 淘宝团队开发的，属于 client 层方案。支持基本的 crud 语法和读写分离，但不支持 join、多表查询等语法。目前使用的也不多，因为还依赖淘宝的 diamond 配置管理系统。")]),t._v(" "),_("li",[_("a",{attrs:{href:"https://github.com/Qihoo360/Atlas",target:"_blank",rel:"noopener noreferrer"}},[t._v("Atlas"),_("OutboundLink")],1),t._v(" - 360 开源的，属于 proxy 层方案，以前是有一些公司在用的，但是确实有一个很大的问题就是社区最新的维护都在 5 年前了。所以，现在用的公司基本也很少了。")]),t._v(" "),_("li",[_("a",{attrs:{href:"https://github.com/dangdangdotcom/sharding-jdbc",target:"_blank",rel:"noopener noreferrer"}},[t._v("sharding-jdbc"),_("OutboundLink")],1),t._v(" - 当当开源的，属于 client 层方案。确实之前用的还比较多一些，因为 SQL 语法支持也比较多，没有太多限制，而且目前推出到了 2.0 版本，支持分库分表、读写分离、分布式 id 生成、柔性事务（最大努力送达型事务、TCC 事务）。而且确实之前使用的公司会比较多一些（这个在官网有登记使用的公司，可以看到从 2017 年一直到现在，是有不少公司在用的），目前社区也还一直在开发和维护，还算是比较活跃，个人认为算是一个现在也"),_("strong",[t._v("可以选择的方案")]),t._v("。")]),t._v(" "),_("li",[_("a",{attrs:{href:"http://www.mycat.org.cn/",target:"_blank",rel:"noopener noreferrer"}},[t._v("Mycat"),_("OutboundLink")],1),t._v(" - 基于 cobar 改造的，属于 proxy 层方案，支持的功能非常完善，而且目前应该是非常火的而且不断流行的数据库中间件，社区很活跃，也有一些公司开始在用了。但是确实相比于 sharding jdbc 来说，年轻一些，经历的锤炼少一些。")])]),t._v(" "),_("p",[t._v("技术选型建议：")]),t._v(" "),_("p",[t._v("建议使用的是 sharding-jdbc 和 mycat。")]),t._v(" "),_("ul",[_("li",[_("a",{attrs:{href:"https://github.com/dangdangdotcom/sharding-jdbc",target:"_blank",rel:"noopener noreferrer"}},[t._v("sharding-jdbc"),_("OutboundLink")],1),t._v(" 这种 client 层方案的"),_("strong",[t._v("优点在于不用部署，运维成本低，不需要代理层的二次转发请求，性能很高")]),t._v("，但是如果遇到升级啥的需要各个系统都重新升级版本再发布，各个系统都需要"),_("strong",[t._v("耦合")]),t._v(" sharding-jdbc 的依赖。其本质上通过配置多数据源，然后根据设定的分库分表策略，计算路由，将请求发送到计算得到的节点上。")]),t._v(" "),_("li",[_("a",{attrs:{href:"http://www.mycat.org.cn/",target:"_blank",rel:"noopener noreferrer"}},[t._v("Mycat"),_("OutboundLink")],1),t._v(" 这种 proxy 层方案的"),_("strong",[t._v("缺点在于需要部署")]),t._v("，自己运维一套中间件，运维成本高，但是"),_("strong",[t._v("好处在于对于各个项目是透明的")]),t._v("，如果遇到升级之类的都是自己中间件那里搞就行了。")])]),t._v(" "),_("p",[t._v("通常来说，这两个方案其实都可以选用，但是我个人建议中小型公司选用 sharding-jdbc，client 层方案轻便，而且维护成本低，不需要额外增派人手，而且中小型公司系统复杂度会低一些，项目也没那么多；但是中大型公司最好还是选用 mycat 这类 proxy 层方案，因为可能大公司系统和项目非常多，团队很大，人员充足，那么最好是专门弄个人来研究和维护 mycat，然后大量项目直接透明使用即可。")]),t._v(" "),_("h2",{attrs:{id:"参考资料"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#参考资料"}},[t._v("#")]),t._v(" 参考资料")]),t._v(" "),_("ul",[_("li",[_("a",{attrs:{href:"https://shardingsphere.apache.org/document/current/cn/overview/",target:"_blank",rel:"noopener noreferrer"}},[t._v("ShardingSphere 官方文档"),_("OutboundLink")],1)]),t._v(" "),_("li",[_("a",{attrs:{href:"https://juejin.im/post/5bf778ef5188251b8a26ed8b",target:"_blank",rel:"noopener noreferrer"}},[t._v('“分库分表" ？选型和流程要慎重，否则会失控'),_("OutboundLink")],1)]),t._v(" "),_("li",[_("a",{attrs:{href:"https://www.jianshu.com/p/32b3e91aa22c",target:"_blank",rel:"noopener noreferrer"}},[t._v("分库分表需要考虑的问题及方案"),_("OutboundLink")],1)]),t._v(" "),_("li",[_("a",{attrs:{href:"https://juejin.im/post/5d4b6dc1f265da03c1288332",target:"_blank",rel:"noopener noreferrer"}},[t._v("一次难得的分库分表实践"),_("OutboundLink")],1)]),t._v(" "),_("li",[_("a",{attrs:{href:"https://www.cnblogs.com/barrywxx/p/11532122.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("分库分表平滑扩容"),_("OutboundLink")],1)])])])}),[],!1,null,null,null);r.default=a.exports}}]);