(window.webpackJsonp=window.webpackJsonp||[]).push([[29],{426:function(s,v,t){"use strict";t.r(v);var _=t(15),o=Object(_.a)({},(function(){var s=this,v=s.$createElement,t=s._self._c||v;return t("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[t("h1",{attrs:{id:"分布式算法-gossip"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#分布式算法-gossip"}},[s._v("#")]),s._v(" 分布式算法 Gossip")]),s._v(" "),t("p",[s._v("Gossip 也叫 Epidemic Protocol （流行病协议），这个协议基于"),t("strong",[s._v("最终一致性")]),s._v("以及"),t("strong",[s._v("去中心化")]),s._v("设计思想。主要用于"),t("strong",[s._v("分布式节点之间进行信息交换和数据同步")]),s._v("，这种场景的一个最大特点就是组成的网络的节点都是对等节点，是非结构化网络（去中心化）。")]),s._v(" "),t("p",[s._v("Gossip 协议最早是在 1987 年发表在 ACM 上的论文 《Epidemic Algorithms for Replicated Database Maintenance》中被提出，其理论基础来源于流行病学的数学模型，这种场景的一个最大特点就是组成的网络的节点都是去中心化的对等节点，在信息同步过程中不能保证某个时刻所有节点都收到消息，但是理论上最终所有节点都会收到消息，实现最终一致性协议。")]),s._v(" "),t("h2",{attrs:{id:"gossip-协议的执行过程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#gossip-协议的执行过程"}},[s._v("#")]),s._v(" Gossip 协议的执行过程")]),s._v(" "),t("p",[t("strong",[s._v("Gossip 协议的执行过程")]),s._v("：")]),s._v(" "),t("p",[s._v("Gossip 过程是由种子节点发起，当一个种子节点有状态需要更新到网络中的其他节点时，它会随机的选择周围几个节点散播消息，收到消息的节点也会重复该过程，直至最终网络中所有的节点都收到了消息。这个过程可能需要一定的时间，由于不能保证某个时刻所有节点都收到消息，但是理论上最终所有节点都会收到消息，因此它是一个最终一致性协议。")]),s._v(" "),t("p",[t("strong",[s._v("为了表述清楚，我们先做一些前提设定")])]),s._v(" "),t("ul",[t("li",[t("strong",[s._v("种子节点")]),s._v("周期性的散播消息，把周期限定为 1 秒")]),s._v(" "),t("li",[s._v("被感染节点随机选择 N 个邻接节点（fan-out）散播消息，这里把 fan-out 设置为 3，每次最多往 3 个节点散播。")]),s._v(" "),t("li",[s._v("节点只接收消息不反馈结果。")]),s._v(" "),t("li",[s._v("每次散播消息都选择"),t("strong",[s._v("尚未发送过的节点")]),s._v("进行散播")]),s._v(" "),t("li",[s._v("收到消息的节点不再往发送节点散播，比如 A -> B，那么 B 进行散播的时候，不再发给 A。")])]),s._v(" "),t("p",[s._v("注意：Gossip 过程是异步的，也就是说发消息的节点不会关注对方是否收到，即不等待响应；不管对方有没有收到，它都会每隔 1 秒向周围节点发消息。"),t("strong",[s._v("异步是它的优点，而消息冗余则是它的缺点")]),s._v("。")]),s._v(" "),t("p",[s._v("Goosip 协议的信息传播和扩散通常需要由种子节点发起。整个传播过程可能需要一定的时间，由于不能保证某个时刻所有节点都收到消息，但是理论上最终所有节点都会收到消息，因此它是一个"),t("strong",[s._v("最终一致性")]),s._v("协议。")]),s._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/dunwu/images/dev/snap/20210708234308.gif",alt:""}})]),s._v(" "),t("h2",{attrs:{id:"gossip-的特点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#gossip-的特点"}},[s._v("#")]),s._v(" Gossip 的特点")]),s._v(" "),t("h3",{attrs:{id:"gossip-的优点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#gossip-的优点"}},[s._v("#")]),s._v(" Gossip 的优点")]),s._v(" "),t("ul",[t("li",[t("strong",[s._v("扩展性")]),s._v("：网络可以允许节点的任意增加和减少，新增加的节点的状态最终会与其他节点一致。")]),s._v(" "),t("li",[t("strong",[s._v("容错")]),s._v("：网络中任何节点的宕机和重启都不会影响 Gossip 消息的传播，Gossip 协议具有天然的分布式系统容错特性。")]),s._v(" "),t("li",[t("strong",[s._v("去中心化")]),s._v("：Gossip 协议不要求任何中心节点，所有节点都可以是对等的，任何一个节点无需知道整个网络状况，只要网络是连通的，任意一个节点就可以把消息散播到全网。")]),s._v(" "),t("li",[t("strong",[s._v("一致性收敛")]),s._v("：Gossip 协议中的消息会以一传十、十传百一样的指数级速度在网络中快速传播，因此系统状态的不一致可以在很快的时间内收敛到一致。消息传播速度达到了 logN。")]),s._v(" "),t("li",[t("strong",[s._v("简单")]),s._v("：Gossip 协议的过程极其简单，实现起来几乎没有太多复杂性。")])]),s._v(" "),t("h3",{attrs:{id:"gossip-的缺陷"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#gossip-的缺陷"}},[s._v("#")]),s._v(" Gossip 的缺陷")]),s._v(" "),t("p",[s._v("分布式网络中，没有一种完美的解决方案，Gossip 协议跟其他协议一样，也有一些不可避免的缺陷，主要是两个：")]),s._v(" "),t("ul",[t("li",[t("strong",[s._v("消息的延迟")]),s._v("：由于 Gossip 协议中，节点只会随机向少数几个节点发送消息，消息最终是通过多个轮次的散播而到达全网的，因此使用 Gossip 协议会造成不可避免的消息延迟。不适合用在对实时性要求较高的场景下。")]),s._v(" "),t("li",[t("strong",[s._v("消息冗余")]),s._v("：Gossip 协议规定，节点会定期随机选择周围节点发送消息，而收到消息的节点也会重复该步骤，因此就不可避免的存在消息重复发送给同一节点的情况，造成了消息的冗余，同时也增加了收到消息的节点的处理压力。而且，由于是定期发送，因此，即使收到了消息的节点还会反复收到重复消息，加重了消息的冗余。")])]),s._v(" "),t("h2",{attrs:{id:"gossip-类型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#gossip-类型"}},[s._v("#")]),s._v(" Gossip 类型")]),s._v(" "),t("p",[s._v("Gossip 有两种类型：")]),s._v(" "),t("ul",[t("li",[t("strong",[s._v("Anti-Entropy(反熵)")]),s._v("：以固定的概率传播所有的数据。Anti-Entropy 是 SI model，节点只有两种状态，Suspective 和 Infective，叫做 simple epidemics。")]),s._v(" "),t("li",[t("strong",[s._v("Rumor-Mongering(谣言传播)")]),s._v("：仅传播新到达的数据。Rumor-Mongering 是 SIR model，节点有三种状态，Suspective，Infective 和 Removed，叫做 complex epidemics。")])]),s._v(" "),t("p",[s._v("熵是物理学上的一个概念，代表杂乱无章，而反熵就是在杂乱无章中寻求一致。")]),s._v(" "),t("p",[s._v("在 SI model 下，一个节点会把所有的数据都跟其他节点共享，以便消除节点之间数据的任何不一致，它可以保证最终、完全的一致。")]),s._v(" "),t("p",[s._v("由于在 SI model 下消息会不断反复的交换，因此消息数量是非常庞大的，无限制的（unbounded），这对一个系统来说是一个巨大的开销。")]),s._v(" "),t("p",[s._v("但是在 Rumor Mongering（SIR Model） 模型下，消息可以发送得更频繁，因为消息只包含最新 update，体积更小。而且，一个 Rumor 消息在某个时间点之后会被标记为 removed，并且不再被传播，因此，SIR model 下，系统有一定的概率会不一致。")]),s._v(" "),t("p",[s._v("而由于，SIR Model 下某个时间点之后消息不再传播，因此消息是有限的，系统开销小。")]),s._v(" "),t("p",[s._v("一般来说，为了在通信代价和可靠性之间取得折中，需要将这两种方法结合使用。")]),s._v(" "),t("p",[t("strong",[s._v("Gossip 中的通信模式")])]),s._v(" "),t("p",[s._v("在 Gossip 协议下，网络中两个节点之间有三种通信方式:")]),s._v(" "),t("ul",[t("li",[s._v("Push: 节点 A 将数据 (key,value,version) 及对应的版本号推送给 B 节点，B 节点更新 A 中比自己新的数据")]),s._v(" "),t("li",[s._v("Pull：A 仅将数据 key, version 推送给 B，B 将本地比 A 新的数据（Key, value, version）推送给 A，A 更新本地")]),s._v(" "),t("li",[s._v("Push/Pull：与 Pull 类似，只是多了一步，A 再将本地比 B 新的数据推送给 B，B 则更新本地")])]),s._v(" "),t("p",[s._v("如果把两个节点数据同步一次定义为一个周期，则在一个周期内，Push 需通信 1 次，Pull 需 2 次，Push/Pull 则需 3 次。虽然消息数增加了，但从效果上来讲，Push/Pull 最好，理论上一个周期内可以使两个节点完全一致。直观上，Push/Pull 的收敛速度也是最快的。")]),s._v(" "),t("h2",{attrs:{id:"参考资料"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#参考资料"}},[s._v("#")]),s._v(" 参考资料")]),s._v(" "),t("ul",[t("li",[t("a",{attrs:{href:"http://bitsavers.trailing-edge.com/pdf/xerox/parc/techReports/CSL-89-1_Epidemic_Algorithms_for_Replicated_Database_Maintenance.pdf",target:"_blank",rel:"noopener noreferrer"}},[s._v("Epidemic Algorithms for Replicated Database Maintenance"),t("OutboundLink")],1)]),s._v(" "),t("li",[t("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/41228196",target:"_blank",rel:"noopener noreferrer"}},[s._v("P2P 网络核心技术：Gossip 协议"),t("OutboundLink")],1)])])])}),[],!1,null,null,null);v.default=o.exports}}]);